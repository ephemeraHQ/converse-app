## General

- When I ask you to "clean" a file, rewrite the content following the rules and best practices listed below.
- When I ask you to "Make more readable", rewrite the content following the rules and best practices listed below and add some comments to explain the code. The comments need to be short and direct. Don't add comments when it's obvious what the code is doing. Also add some comments to explain why we are doing something in a certain way.

## Core Principles

- Write concise TypeScript code.
- Use functional programming patterns.
- Prefer clean, readable code over compact code, using empty lines to separate logical blocks.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Don't create functions inside other functions unless specified.
- Add clear, concise comments to explain non-obvious logic.
- Handle errors at the caller level unless logging is needed.
- Minimize using external hooks inside custom hooks to prevent unnecessary rerenders.
- Use Zod for external API response validation.
- Keep files small and focused.
- Use block-style if statements with curly braces instead of single-line statements.
- Use logger for all logging operations:

```typescript
// ❌ Bad: Single-line if statement
if (isValid) return

// ✅ Good: Block-style if statement
if (isValid) {
  return
}
```

## Imports

- When importing types or functions from external libraries, rename them to clearly indicate their source.
- Use the 'as' keyword to rename imports from third-party libraries.

```typescript
// ❌ Bad: Importing without renaming
// ✅ Good: Renaming imports to indicate source
import {
  createWallet,
  createWallet as createWalletThirdweb,
  Wallet as ThirdwebWallet,
  Wallet,
} from "thirdweb/wallets"
```

## Code Organization

- Place exported functions, components, and variables at the top of the file.
- Place helper functions and non-exported components below the exported items.
- Define types close to their implementation:
  - Place type definitions directly above the function or component that uses them.
  - Only place types at the top of the file if they're used in multiple places throughout the file.

```typescript
// ❌ Bad: Helper function above exported function
function formatUserName(firstName: string, lastName: string) {
  return `${firstName} ${lastName}`
}

export function UserProfile(args: { userId: string }) {
  // Implementation
}

// ✅ Good: Exported function at the top, helper below
export function UserProfile(args: { userId: string }) {
  // Implementation using formatUserName
}

function formatUserName(firstName: string, lastName: string) {
  return `${firstName} ${lastName}`
}

// ❌ Bad: Type definition far from implementation
type IFormatOptions = {
  uppercase: boolean
  includeMiddleName: boolean
}

// Many lines of code...

function formatName(args: { name: string; options: IFormatOptions }) {
  // Implementation
}

// ✅ Good: Type definition close to implementation
type IFormatOptions = {
  uppercase: boolean
  includeMiddleName: boolean
}

function formatName(args: { name: string; options: IFormatOptions }) {
  // Implementation
}
```

## TypeScript

- Use types over interfaces, prefixed with 'I'.
- Never use 'any'.
- Avoid enums, use string literals instead.
- Prefer type inference when possible.
- Avoid explicit Promise return types - let TypeScript infer them.

```typescript
// ❌ Bad: Explicit Promise return types
async function fetchUser(id: string): Promise<IUser> {
  return api.getUser(id)
}

// ✅ Good: Let TypeScript infer the Promise return type
async function fetchUser(id: string) {
  return api.getUser(id)
}

// ✅ Good: Non-Promise return types are still fine to be explicit
function calculateTotal(items: ICartItem[]): number {
  return items.reduce((sum, item) => sum + item.price, 0)
}
```

## Function Parameters

- Use object parameters with inline types.
- Destructure parameters at the top of the function body.

```typescript
// ❌ Bad: Individual parameters
function sendMessage(recipientId: string, content: string) {
  // Function body
}

// ✅ Good: Object parameters with destructuring
function sendMessage(args: { recipientId: string; content: string }) {
  const { recipientId, content } = args
  // Function body
}
```

## React & Components

- Use named exports.
- Write JSX inline.
- Prefer early returns over ternaries.
- Minimize useEffect usage.
- Wrap components in memo() for performance.
- This codebase uses React Native - follow all React Native best practices.
- Never place hooks inside conditionals, loops, or nested functions - this violates React's Rules of Hooks.
- Avoid using render functions (renderHeader, renderContent, etc.) within components. Instead, create separate component functions for each logical UI section.
- For styling components, use the style prop with an object instead of direct props:

```typescript
// ❌ Bad: Using style props directly
<HStack alignItems="center" gap={theme.spacing.sm}>

// ✅ Good: Using style object
<HStack
  style={{
    alignItems: "center",
    gap: theme.spacing.sm,
  }}
>
```

```typescript
// ❌ Bad: Using render functions inside components
export const ProfileScreen = memo(function ProfileScreen() {
  const renderHeader = () => (
    <Header title="Profile" />
  )

  const renderContent = () => (
    <VStack>
      <Avatar />
      <Text>User Name</Text>
    </VStack>
  )

  return (
    <Screen>
      {renderHeader()}
      {renderContent()}
    </Screen>
  )
})

// ✅ Good: Using separate component functions
export const ProfileScreen = memo(function ProfileScreen() {
  return (
    <Screen>
      <ProfileHeader />
      <ProfileContent />
    </Screen>
  )
})

const ProfileHeader = memo(function ProfileHeader() {
  return <Header title="Profile" />
})

const ProfileContent = memo(function ProfileContent() {
  return (
    <VStack>
      <Avatar />
      <Text>User Name</Text>
    </VStack>
  )
})
```

- Avoid creating unnecessary external prop type declarations when extending existing component props.
- Create wrapper components by extending base components when adding consistent styling or behavior.

```typescript
// ❌ Bad: Unnecessary external prop type declaration
type IConnectWalletButtonContainerProps = {
  children: ReactNode;
  style?: StyleProp<ViewStyle>;
} & Omit<IVStackProps, 'children' | 'style'>;

export const ConnectWalletButtonContainer = memo(
  function ConnectWalletButtonContainer(props: IConnectWalletButtonContainerProps) {
    const { children, style, ...rest } = props;
    const { theme } = useAppTheme();

    return (
      <VStack
        style={[
          {
            rowGap: theme.spacing.xxs,
          },
          style,
        ]}
        {...rest}
      >
        {children}
      </VStack>
    );
  }
);

// ✅ Good: Directly use the base component's props
export const ConnectWalletButtonContainer = memo(
  function ConnectWalletButtonContainer(props: IVStackProps) {
    const { children, style, ...rest } = props;
    const { theme } = useAppTheme();

    return (
      <VStack
        style={[
          {
            rowGap: theme.spacing.xxs,
          },
          style,
        ]}
        {...rest}
      >
        {children}
      </VStack>
    );
  }
);
```

## File Structure

- Use lower-kebab-case for directories and files.
- Import paths should start with @/.
- Place files as close as possible to where they are used.
- Follow the feature-based organization pattern.
- Use descriptive suffixes for files that indicate their purpose.

```
// ❌ Bad: Unclear names
utils.ts
types.ts

// ✅ Good: Clear names with feature prefix and purpose suffix
profile.screen.tsx
messages.query.ts
auth.client.ts
```

### Feature-Based Organization

Organize code by features rather than technical concerns. Each feature should be self-contained with its own components, screens, utilities, etc.

Feature directories may contain:

- `components/` - UI components specific to the feature
- `screens/` - Screen components for the feature
- `navigation/` - Navigation-related code
- `hooks/` - Custom hooks
- `utils/` - Utility functions
- `data/` - Data management
- `clients/` - API clients
- `queries/` - React Query related code
- `types/` - TypeScript types
- `actors/` - XState actors

### File Naming Convention

Name files with the feature name as prefix and a descriptive suffix indicating the file's purpose:

```
[featureName].screen.tsx
[featureName].nav.tsx
[featureName].store.ts
[featureName].query.ts
[featureName].utils.ts
[featureName].types.ts
[featureName].test.ts
```

Example structure:

```
features/
└── accounts/
    ├── components/
    │   ├── account-card.component.tsx
    │   └── account-settings.component.tsx
    ├── screens/
    │   └── accounts.screen.tsx
    ├── navigation/
    │   └── accounts.nav.tsx
    ├── hooks/
    │   └── accounts.hooks.ts
    ├── utils/
    │   └── accounts.utils.ts
    ├── data/
    ├── accounts.query.ts
    └── accounts.types.ts
```

This organization ensures that:

1. Related code stays together
2. Files are easy to find based on their name
3. The purpose of each file is clear from its suffix
4. Features are modular and self-contained

## React Query Best Practices

- Define query keys in QueryKeys.ts.
- Use queryOptions helper for type safety.
- Handle conditional fetching with enabled flag.

```typescript
// ❌ Bad: Direct key usage
const { data } = useQuery(["messages", id])

// ✅ Good: Using query options
export const getMessagesQueryOptions = (args: { id: string }) => {
  const enabled = !!args.id

  return queryOptions({
    queryKey: messagesQueryKey(args.id),
    queryFn: enabled ? () => fetchMessages(args) : skipToken,
    enabled,
  })
}
```

## Zustand Store Best Practices

- Use Zustand stores to centralize state and actions, especially when passing many props between components.
- Structure stores with a clear separation between state and actions:

```typescript
// ✅ Good: Clear separation of state and actions
export const useCounterStore = create<ICounterStore>((set) => ({
  // State
  count: 0,
  isLoading: false,

  // Actions
  actions: {
    increment: () => set((state) => ({ count: state.count + 1 })),
    decrement: () => set((state) => ({ count: state.count - 1 })),
    reset: () => set({ count: 0 }),
    fetchCount: async () => {
      set({ isLoading: true })
      try {
        const count = await api.getCount()
        set({ count, isLoading: false })
      } catch (error) {
        set({ isLoading: false })
        throw new AppError({
          error,
          additionalMessage: "Failed to fetch count",
        })
      }
    },
  },
}))
```

- Prefer using the store directly in components over prop drilling:

```typescript
// ❌ Bad: Prop drilling
function ParentComponent() {
  const count = useCounterStore((state) => state.count);
  const increment = useCounterStore((state) => state.actions.increment);

  return <ChildComponent count={count} increment={increment} />;
}

// ✅ Good: Direct store usage
function ChildComponent() {
  const count = useCounterStore((state) => state.count);
  const { increment } = useCounterStore((state) => state.actions);

  return (
    <Button onPress={increment}>
      Count: {count}
    </Button>
  );
}
```

- Use selectors to minimize re-renders:

```typescript
// ❌ Bad: Getting the entire store
const { count, actions } = useCounterStore()

// ✅ Good: Using selectors for specific values
const count = useCounterStore((state) => state.count)
const { increment } = useCounterStore((state) => state.actions)
```

## Error Handling

- Prefer throwing errors over catching them, unless the catch block is where we want to handle the error UI/UX.
- When catching errors, only do so at the level where you need to handle the user experience.
- Use captureError only when you need to log the error but continue execution.
- Add context to errors when throwing them up the chain.
- Always throw XMTPError to maintain consistent error handling.

```typescript
// ❌ Bad: Catching and capturing error when we should throw
try {
  await sendMessage(content)
} catch (error) {
  captureError(new XMTPError({ error }))
}

// ❌ Bad: Catching error too early
async function sendMessage(args: { content: string }) {
  try {
    await xmtpClient.send(args.content)
  } catch (error) {
    captureError(new XMTPError({ error }))
  }
}

// ✅ Good: Throwing error for parent to handle
async function sendMessage(args: { content: string }) {
  try {
    await xmtpClient.send(args.content)
  } catch (error) {
    throw new XMTPError({
      error,
      additionalMessage: "Failed to send message",
    })
  }
}

// ✅ Good: Catching error where we handle the UX
function MessageComponent() {
  const sendMessage = async () => {
    try {
      await messagingService.sendMessage({ content })
    } catch (error) {
      // Here we actually handle the error for the user
      captureErrorWithToast(error)
    }
  }
}
```
