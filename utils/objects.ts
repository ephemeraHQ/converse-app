export const pick = <T extends object, K extends keyof T>(obj: T, keys: K[]) =>
  Object.fromEntries(keys.filter((key) => key in obj).map((key) => [key, obj[key]])) as Pick<T, K>

// Generated by AI
export function isDifferent(obj1: unknown, obj2: unknown): boolean {
  // Handle primitive types and null
  if (obj1 === obj2) {
    return false
  }

  // Check if either value is null or not an object
  if (obj1 === null || obj2 === null || typeof obj1 !== "object" || typeof obj2 !== "object") {
    return true
  }

  // Handle Arrays
  if (Array.isArray(obj1) && Array.isArray(obj2)) {
    if (obj1.length !== obj2.length) {
      return true
    }

    for (let i = 0; i < obj1.length; i++) {
      if (isDifferent(obj1[i], obj2[i])) {
        return true
      }
    }

    return false
  }

  // Handle Date objects
  if (obj1 instanceof Date && obj2 instanceof Date) {
    return obj1.getTime() !== obj2.getTime()
  }

  // For regular objects, compare keys and then values
  const keys1 = Object.keys(obj1)
  const keys2 = Object.keys(obj2)

  if (keys1.length !== keys2.length) {
    return true
  }

  // Check if all keys in obj1 exist in obj2 with the same values
  for (const key of keys1) {
    if (!Object.prototype.hasOwnProperty.call(obj2, key)) {
      return true
    }

    if (
      isDifferent((obj1 as Record<string, unknown>)[key], (obj2 as Record<string, unknown>)[key])
    ) {
      return true
    }
  }

  return false
}

export function isEqual(obj1: unknown, obj2: unknown): boolean {
  return !isDifferent(obj1, obj2)
}

export function isEmpty(obj: unknown): boolean {
  if (obj === null || obj === undefined) {
    return true
  }

  if (Array.isArray(obj)) {
    return obj.length === 0
  }

  if (typeof obj === "object") {
    return Object.keys(obj).length === 0
  }

  return false
}
